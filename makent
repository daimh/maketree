#!/usr/bin/env python3
# Author: Manhong Dai, manhongdai@gmail.com
# License: GPLv3
import argparse
import subprocess
import sys


class Node():
	def __init__(self, target, parent):
		self.target = target
		self.parent = parent
		self.children = []
		self.need_remake = False

	def trim_me(self):
		self.children = [chld for chld in self.children if chld.trim_me()]
		self.need_remake = self.need_remake or len(self.children) > 0
		return self.need_remake

	def print_me(self, depth=0, spaces=[]):
		for i in range(depth):
			if i == depth - 1:
				if spaces[i]:
					print('├──', end='')
				else:
					print('└──', end='')
			else:
				if spaces[i]:
					print('│  ', end='')
				else:
					print('   ', end='')
		if depth > 0:
			if self.need_remake:
				print(self.target)
			else:
				print(self.target, '(up to date)')
		count = len(self.children)
		printed = False
		for idx in range(count):
			if self.children[idx].print_me(depth+1, spaces+[idx < count-1]):
				printed = True
		return printed

	def parse(self, lines, row):
		considered = set()
		wait = True
		node = self
		while row < len(lines):
			ln = lines[row]
			row += 1
			if not ln.endswith('.'):
				continue
			elif wait:
				wait = not ln.startswith('Updating goal targets')
				continue
			elif ln.startswith('Putting child '):
				recursion = Node('┐', node)
				row = recursion.parse(lines, row+1)
				target = ln[ln.index('(')+1:ln.rindex(')')]
				node.children.append(recursion)
			elif ln.startswith('Removing child '):
				return row + 1
			elif "Considering target file " in ln:
				target = ln[ln.index("'")+1:ln.rindex("'")]
				if target in considered:
					if lines[row].strip() != f"File '{target}' was considered already.":
						quit(f'ERR-002: contact developer with "{ln}"')
					row += 1
					continue
				child = Node(target, node)
				node.children.append(child)
				node = child
			elif "No need to remake target " in ln:
				target = ln[ln.index("'")+1:ln.rindex("'")]
				node.need_remake = False
				considered.add(target)
				node = node.parent
			elif "Must remake target " in ln:
				target = ln[ln.index("'")+1:ln.rindex("'")]
				node.need_remake = True
				considered.add(target)
				node = node.parent


def get_args():
	parser = argparse.ArgumentParser()
	parser.add_argument(
		"MakeArguments",
		help=(
			"arguments passed to make. Tip: Use '--' to separate them from"
			"makent's own arguments. E.g., 'makent -a -- -B'"),
		nargs='*')
	parser.add_argument("-V", "--version", action='version', version='20221113')
	parser.add_argument(
		"-a",
		"--all",
		help="show all make targets including those up to date.",
		action="store_true",
		required=False)
	return parser.parse_args()


def quit(msg):
	print(msg)
	sys.exit(1)


def check_make_version():
	try:
		ps = subprocess.run(['make', '--version'], stdout=subprocess.PIPE)
		if ps.returncode != 0:
			sys.exit(1)
	except FileNotFoundError:
		quit("ERR-003: No 'make' in your PATH")
	if ps.stdout[:9] != b'GNU Make ' or ps.stdout[9:11] in [b'3.', b'2.', b'1.']:
		quit("ERR-004: 'make' is not version 4 or newer")


def main():
	check_make_version()
	args = get_args()
	make = ['make', '-d', '-nt']
	make += args.MakeArguments
	ps = subprocess.run(make, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	del make[1]
	if ps.returncode != 0:
		quit(f"'make -nt' failed with exit code {ps.returncode}")
	lines = str(ps.stdout, 'utf-8').split('\n')
	root = Node('/' + ' '.join(make), None)
	root.parse(lines, 0)
	if not args.all:
		root.trim_me()
	root.print_me()


if __name__ == '__main__':
	main()
